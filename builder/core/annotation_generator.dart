import 'dart:io';
import 'package:dart_style/dart_style.dart';
import '../annotations/registry.dart';
import '../annotations/base_annotation.dart';

class AnnotationGenerator {
  final AnnotationRegistry _registry;

  AnnotationGenerator(this._registry);
  String generateAnnotationsFile() {
    final buffer = StringBuffer();

    // Header comment
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by builder.dart at ${DateTime.now()}');
    buffer.writeln();

    // Annotation classes (generated from registry)
    for (final processor in _registry.processors) {
      buffer.writeln(_generateAnnotationClass(processor));
      buffer.writeln();
    }

    // Convenience constants (generated from registry)
    buffer.writeln(_generateConvenienceConstants());

    try {
      final formatter = DartFormatter();
      return formatter.format(buffer.toString());
    } catch (e) {
      print('‚ö†Ô∏è  Warning: Could not format annotations file: $e');
      return buffer.toString();
    }
  }

  String _generateAnnotationClass(BaseAnnotationProcessor processor) {
    final annotationName = processor.annotationName;
    final parameters = processor.annotationParameters;
    final comment = processor.annotationComment;

    if (parameters.isEmpty) {
      // Simple annotation without parameters
      return '''
$comment
class $annotationName {
  const $annotationName();
}''';
    }

    // Annotation with parameters
    final fieldsBuffer = StringBuffer();
    final constructorBuffer = StringBuffer();

    // Generate final fields
    for (final param in parameters) {
      fieldsBuffer.writeln('  final ${param.type} ${param.name};');
    }

    // Generate constructor parameters
    final constructorParams = parameters
        .map((param) {
          final defaultValue = param.defaultValue;
          if (defaultValue != null) {
            return 'this.${param.name} = $defaultValue';
          }
          return 'this.${param.name}';
        })
        .join(',\n    ');

    return '''
$comment
class $annotationName {
${fieldsBuffer.toString().trimRight()}

  const $annotationName({
    $constructorParams,
  });
}''';
  }


  String _generateConvenienceConstants() {
    final buffer = StringBuffer();
    buffer.writeln('// Convenience constants for common use');

    for (final processor in _registry.processors) {
      // Use the first alias as the constant name, if available
      if (processor.annotationAliases.isNotEmpty) {
        final constantName = processor.annotationAliases.first;
        final className = processor.annotationName;
        buffer.writeln('const $constantName = $className();');
      }
    }

    return buffer.toString().trim();
  }

  void writeAnnotationsFile(String outputPath) {
    final content = generateAnnotationsFile();
    File(outputPath).writeAsStringSync(content);
    print('üìÑ Generated annotations: $outputPath');
  }
}
