import '../index.dart';
import 'package:path/path.dart' as path;

class CodeBuilder {
  final List<String> _imports = [];
  final List<String> _generatedCode = [];
  final List<String> _initializerClasses = [];
  final AnnotationRegistry _registry;
  String _sourceDir = '';

  CodeBuilder(this._registry);

  void generateFiles(String sourceDir) {
    print('üîç Scanning directory: $sourceDir');

    _sourceDir = path.normalize(path.absolute(sourceDir));
    _scanDirectory(sourceDir);

    // Generate annotations.g.dart
    final annotationGenerator = AnnotationGenerator(_registry);
    final annotationsPath = path.join(sourceDir, 'annotations.g.dart');
    annotationGenerator.writeAnnotationsFile(annotationsPath);

    // Generate builder.g.dart
    final builderPath = path.join(sourceDir, 'builder.g.dart');
    if (_generatedCode.isEmpty && _initializerClasses.isEmpty) {
      print('‚ö†Ô∏è  No annotations found to generate extensions for');
    }
    final output = _buildOutputFile();
    File(builderPath).writeAsStringSync(output);
    final totalSections =
        _generatedCode.length + (_initializerClasses.isNotEmpty ? 1 : 0);
    print('‚úÖ Generated $totalSections code sections');

    print('üìÑ Generated files:');
    print('  ‚Ä¢ $annotationsPath');
    print('  ‚Ä¢ $builderPath');
  }

  void _scanDirectory(String dirPath) {
    final directory = Directory(dirPath);
    if (!directory.existsSync()) {
      print('‚ùå Directory does not exist: $dirPath');
      return;
    }

    directory.listSync(recursive: true).forEach((entity) {
      if (entity is File &&
          entity.path.endsWith('.dart') &&
          !entity.path.endsWith('.g.dart')) {
        _scanFile(entity);
      }
    });
  }

  void _scanFile(File file) {
    try {
      final content = file.readAsStringSync();
      final parseResult = parseString(content: content);
      final visitor = AnnotationVisitor(this, file.path, _sourceDir, _registry);
      parseResult.unit.accept(visitor);
    } catch (e) {
      print('‚ö†Ô∏è  Error parsing ${file.path}: $e');
    }
  }

  void addImport(String import) {
    if (!_imports.contains(import)) {
      _imports.add(import);
    }
  }

  void addGeneratedCode(String code) {
    _generatedCode.add(code);
  }

  void addInitializerClass(String className) {
    if (!_initializerClasses.contains(className)) {
      _initializerClasses.add(className);
    }
  }

  String _buildOutputFile() {
    final buffer = StringBuffer();

    // Header comment
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by builder.dart at ${DateTime.now()}');
    buffer.writeln();

    // Imports
    if (_imports.isNotEmpty) {
      buffer.writeln('// ignore_for_file: unused_import');
      final sortedImports = _imports.toSet().toList()..sort();
      for (final import in sortedImports) {
        buffer.writeln(import);
      }
      buffer.writeln();
    }

    // Generated code
    for (final code in _generatedCode) {
      buffer.writeln(code);
      buffer.writeln();
    }

    // Always generate InitializeBuilder function
    buffer.writeln(_generateInitializeBuilder());
    buffer.writeln();

    try {
      final formatter = DartFormatter(languageVersion: Version.parse('3.6.0'));
      return formatter.format(buffer.toString());
    } catch (e) {
      print('‚ö†Ô∏è  Warning: Could not format generated code: $e');
      return buffer.toString();
    }
  }

  String _generateInitializeBuilder() {
    final sortedClasses = _initializerClasses.toList()..sort();
    final buffer = StringBuffer();

    buffer.writeln(
      '/// Global initializer function that calls all initialize() methods',
    );
    buffer.writeln(
      '/// and executes their optional callbacks after initialization',
    );
    buffer.writeln('void builderInitializer() {');

    if (_initializerClasses.isEmpty) {
      buffer.writeln(
        '  // No @Initializer classes found - empty implementation',
      );
    } else {
      buffer.writeln('  final callbacks = <Function()>[];');
      buffer.writeln();
      buffer.writeln('  // Call all initialize methods and collect callbacks');

      for (final className in sortedClasses) {
        final varName = '${className.toLowerCase()}Callback';
        buffer.writeln('  final $varName = $className.initialize();');
        buffer.writeln('  if ($varName != null) callbacks.add($varName);');
        buffer.writeln();
      }

      buffer.writeln('  // Execute all callbacks after initialization');
      buffer.writeln('  for (final callback in callbacks) {');
      buffer.writeln('    callback();');
      buffer.writeln('  }');
    }
    buffer.writeln('}');

    return buffer.toString();
  }

  String generateImportPath(String filePath) {
    final normalizedFilePath = path.normalize(path.absolute(filePath));
    final normalizedSourceDir = path.normalize(path.absolute(_sourceDir));

    if (normalizedFilePath.startsWith(normalizedSourceDir)) {
      final relativePath = path.relative(
        normalizedFilePath,
        from: normalizedSourceDir,
      );
      final importPath = relativePath.replaceAll('\\', '/');
      return "import '$importPath';";
    }
    return '';
  }
}

class AnnotationVisitor extends RecursiveAstVisitor<void> {
  final CodeBuilder builder;
  final String filePath;
  final String sourceDir;
  final AnnotationRegistry registry;

  AnnotationVisitor(this.builder, this.filePath, this.sourceDir, this.registry);

  @override
  void visitClassDeclaration(ClassDeclaration node) {
    final className = node.name.lexeme;
    bool hasAnnotations = false;

    for (final metadata in node.metadata) {
      final annotationName = metadata.name.name;
      final processor = registry.findProcessor(annotationName);

      if (processor != null) {
        // Check if this is an Initializer annotation
        if (annotationName == 'Initializer' ||
            annotationName == 'initializer') {
          builder.addInitializerClass(className);
          // Also call processAnnotation for Initializer to print extended class info
          processor.processAnnotation(
            node,
            className,
            filePath,
            metadata,
          );
          hasAnnotations = true;
        } else {
          // Handle other annotations that generate code
          final generatedCode = processor.processAnnotation(
            node,
            className,
            filePath,
            metadata,
          );
          if (generatedCode != null) {
            builder.addGeneratedCode(generatedCode);
            hasAnnotations = true;
          }
        }
      }
    }

    // Add import for this file if it has annotations
    if (hasAnnotations) {
      final importPath = builder.generateImportPath(filePath);
      if (importPath.isNotEmpty) {
        builder.addImport(importPath);
      }
    }

    super.visitClassDeclaration(node);
  }
}
